'use strict';

const { RSocketClient, JsonSerializer, IdentitySerializer } = require("rsocket-core");
const RSocketWebSocketClient = require("rsocket-websocket-client").default;

class Engine {
    constructor(script, events) {
        this.script = script;
        this.events = events;
        this.clients = new Map();
    }

    //
    // Required by Artillery: convert scenario spec to runnable scenario
    //
    createScenario(scenarioSpec, ee) {
        const steps = scenarioSpec.flow;

        return {
            name: scenarioSpec.name,
            steps
        };
    }

    //
    // Required by Artillery: create VU runner that executes steps
    //
    createVuser(scenario, vuserContext) {
        return {
            run: async () => {
                const vu = vuserContext;

                const url = this.script.config.target.replace("http", "ws");

                // Connect RSocket
                const client = new RSocketClient({
                    serializers: {
                        data: JsonSerializer,
                        metadata: IdentitySerializer
                    },
                    transport: new RSocketWebSocketClient({ url }),
                    setup: {
                        keepAlive: 10000,
                        lifetime: 20000,
                        dataMimeType: "application/json",
                        metadataMimeType: "message/x.rsocket.routing.v0"
                    }
                });

                const rsocket = await client.connect();
                this.clients.set(vu.id, rsocket);
                vu.state.rsocket = rsocket;

                // Run steps sequentially
                for (const step of scenario.steps) {
                    await this.runStep(vu, step);
                }

                // Close RSocket
                rsocket.close();
            }
        };
    }

    //
    // Step runner
    //
    async runStep(vu, step) {
        const rs = vu.state.rsocket;

        // Send (fireAndForget)
        if (step.send) {
            const payload = JSON.parse(step.send.text);

            const metadata =
                String.fromCharCode(step.send.route.length) + step.send.route;

            rs.fireAndForget({
                data: payload.data,
                metadata
            });
        }

        // sleep (think)
        if (step.think) {
            await new Promise(r => setTimeout(r, step.think * 1000));
        }
    }
}

module.exports = Engine;